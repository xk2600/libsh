#!/bin/sh

# source this file to include function helpers

DEBUGGING_ENABLED=true



###############################################################################
## SETUP ENVIRONMENT


# MANAGES DEBUGGING
#
if $DEBUGGING_ENABLED; then
  debug() {
    local SCRIPT   ;# $0
    local TYPE     ;# $1
    local OBJNAME  ;# $2

    local FORMAT
    SCRIPT=$0
    TYPE=$1
    LINE=$2
    OBJNAME=$3
    shift 3

    case $TYPE in
          var*)    FORMAT='%s[%s]: %s="%s"\n' ;;
          func*)   FORMAT='%s[%s]: %s: %s\n'  ;;
          *)       return 1 ;;
    esac
    printf "$FORMAT" "${SCRIPT}" "${LINE}" "${OBJNAME}" "$*"
  }
else
  debug() {
    # NOOP
  }
fi



###############################################################################
# SETUP DIRECTORY
CLIROOT=$(dirname $( realpath $0 ))/cli
debug var $LINENO CLIROOT $CLIROOT
export CLIROOT



##############################################################################
# MAKE SURE ALL BINARIES ARE EXECUTABLE!
chmod 775 ${CLIROOT}/bin/* \
  || debug func $LINENO chmod "failed to make contents of ${CLIROOT}/bin executable"


## LOCAL UTILITY FUNCTIONS (DROPPED OUTSIDE OF LOCAL CONTEXT)

# read_heredoc
#       reads a heredoc into a variable maintaining all whitespace
#
# ARGS
#
#       VARNAME:   name of the variable to assign data to
# 
# EXAMPLE
#
#       $ read_heredoc VAR <<EOF
#       >   ...   some   ...
#       >   ... contents ...
#       > EOF
#
#       $ echo "$VAR"
#         ...   some   ...
#         ... contents ...
#
read_heredoc() {
  local LINE
  local LAMBDA
  VARNAME=$1

  while IFS="\n" read -r LINE
   do 
    # setvar $VARNAME `printf '\"\${%s}%s\n\"' ${VARNAME} "$LINE"`
    # ^^^ DOESN'T WORK ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    
    # ?
    # eval ${VARNAME}=\$${VARNAME}\${LINE}

    # WORKS
    eval `printf '%s=\"\${%s}%s\n\"' ${VARNAME} ${VARNAME} "${LINE}"`
   done
}
debug func $LINENO function 'read::heredoc() defined'




split() {
  local LIST
  local ATOM

  [ ! $# -eq 2 ] && printf "usage: split string delim" >2 && exit 1

  OFS="$IFS"
  IFS="$2"
  for ATOM in $1; do 
    LIST="${LIST} '${ATOM}'"
  done
  IFS=$OFS
  printf "$LIST\n"
}
debug func $LINENO function 'split() defined'


assign() {
  local VARNAME
  while [ $# -gt 0 ]; do
    
  done
  echo "${ARGS%?}"
}
debug func $LINENO function 'assign() defined.'


ARGS() {
  local ARGS=`printf "'%s' " "$@"`   ;# wraps each argument in ticks (')
  echo "${ARGS%?}"                   ;# removes the last space
}
debug func $LINENO function 'ARGS() defined.'


# fn syntax 
# 
#
fn::syntax() {
  local FNNAME=$1 ; shift
  printf 'function def "%s" ambiguous args: %s' "${FNNAME}" `ARGS "$@"`
}
debug func $LINENO function 'fn::syntax() defined.'

fn::args() {
  local ARGS
  while [ $# -gt 0 ] ; do
    # if last positional is a possibility $@: '*}' '{'
    if [ $# -eq 2 ] ; then
      [ ! "$2" \> '{'] && set -- "$1"
    fi
    case $1 in
      '{*') ARGS=${ARGS:-${ARGS}${1#?}} ;
            ARGS=${ARGS:+${ARGS} $1} ; shift ;;
      '*}') ARGS=${ARGS%?} ; shift ;;
    esac
  done
  printf "%s\n" $ARGS
}
debug func $LINENO function 'fn::args() defined.'

fn() {
  local FNAME
  local ARGS
  local BODY

  ARGS=`f::args "$@"`
  # iterate over args and create 'local <ARGNAME>', setting it
  # to the positional 
  # :TODO:

  while IFS="\n" read -r LINE ; do
    eval `printf '%s=\"\${%s}%s\n\"' ${FNAME} ${ARGS} "${LINE}"`
  done      

}
debug func $LINENO function 'fn() defined.'


# 
#
# cli info usage 
#       usage function generator
#
# cli info help
#       help function generator
#
# cli info args
#       args function args generator
#
# cli doc 
#
# cli doc command COMMAND DESCRIPTION <<\END
#
#   summary text describing the function
#
# ARGS
#
#   [ARGNAME [DESCRIPTION]]
#   [ARGNAME [DESCRIPTION]]
#
#   the rest of these lines are reserved for
#   manpage style help output.
# 
# END
#
# EXAMPLE: (could be in .syntax script or in actual script file)
#
# cli syntax command github "interact with github service" <<\END
#
#   Provides the ability to interact with the GitHub REST API
#   service.
#   
# END
#

cli::doc::definition() {
  local COMMAND
  local CMD_DESCR
  local CMD_SUMMARY
  local ARGLIST
  local ARG

  read_heredoc METAFN <<__METAFN_END
    syntax_$FNNAME() {
      
    }
__METAFN_END
  eval '$MEAFN'
  
}
debug func $LINENO function 'cli::doc::definition() defined.'



###############################################################################
## DEFINE FUNCTIONS


# usage 
#
#
usage() {
  OFS=$IFS
  IFS="\n"
  for f in $@; do
    echo 'usage: $@'
  done
  IFS=OFS
  exit -1
}
debug func $LINENO function 'usage() defined.'


#
# cli command context
#       returns path of currently executing script relative to LIBROOT
#
# cli command expand
#       strips path separator from cli_command list
#
# cli command import
#       creates and tracks alias exposing subcommands in native form
#
# cli command help [CMDNAME]
#       provides contextual help for a cli_command
#
# cli command list [CMDNAME]  
#       lists cli_commands from ${BINROOT}
#
# cli command parse [[CMDNAME]..]
#       takes cli_command string and returns path and executable with args relative
#       to LIBROOT. Sets CLIARGS
#
# cli command path
#       returns path of 
#
# cli command register [all|CNAME] 
#       registers contextual help and enables cli_command in shell
#
# cli command syntax [SUBCLI] [
#       syntax definition
#
#
# ARGUMENTS
#                 
#       all         all cli commands
#       CNAME       the cli command we're looking up the syntax tree for
#       CMDPATH     relative path and executable script relative to $LIBROOT
#       CMDARGS     trailing args after in command string
#
# EXAMPLES
#
#       $ cli command list                  ;# -> empty response...
#       
#       $ cli command register junk         l# -> error response...
#       failed: junk does not exists in CLIROOT
#
#       $ cli command register github       ;# -> returns found commands which were
#       github/repo/create              ;# -> registered during invocation
#
#       $ cli command list                  ;# -> returns list of commands known by
#       github/repo/create              ;#    CLILIB
#
#       $ cli command expand `command list` ;# -> creates a github repo with 
#       github repo create              l#    cli_command registered
#
#       $ cli command help github repo
#       cli_command help 
#
#       $ cli command parse github repo create testrepo arg2 arg3 arg4
#       github/repo/create testrepo arg2 arg3 arg4
#
#       $ cli command syntax 'github repo create' 'lists commands from ${BINROOT}' '
#
#

cli::command::context() {
  local SCRIPTPATH
  if [ $# -gt 0 ]; then
    # WITH ARGS: SET CONTEXT
    SCRIPTPATH=`realpath $PWD/$0`
    __CLICONTEXT=`cli_command path $SCRIPTPATH`
  else
    # NO ARGS: READ CONTEXT
    echo $CLI_CONTEXT
  fi
}
debug func $LINENO function 'cli::command::context() created.'

cli::command::parse_all() {
}
debug func $LINENO function 'cli::command::parse_all() created.'

cli::command::parse() {
  local ATOM

  [ ! $# -gt 0 ] && { echo 'cli_command parse: called without arguments.' ; exit ; }

  CLIPATH="${LIBROOT}"
  while [ $# -gt 0 ]; do
    ATOM=$1 ; shift
    PATH=${CMDPATH}/${ATOM}
    [ -d "${LIBROOT}/${CLIPATH}" ] && continue
    [ -f "${LIBROOT}/${CLIPATH}" ] && break
  done

  while [ $# -gt 0 ]; do
    ATOM=$1 ; shift
    CMDARGS="${CMDARGS} \"${ATOM}\""
  done
  printf "${CMDPATH} ${ARGS}\n"
}
debug func $LINENO function 'cli::command::parse() created.'

cli::command::list() {
  local ROOTLEN
  local CLIPATH

  CLISTRING=`cli::command::parse "$@"`
  CLIPATH=`cli::command::parse "$@"`
  ROOTLEN="${CLIROOT}/lib.."
  ROOTLEN="${#ROOTLEN}"
  CMDLIST=`find "${CLIROOT}/lib/${CLIPATH}" -type f -regex '[^.]*$' | cut -b ${ROOTLEN}-`
  # iterate over commands in CMDLIST and append the 'cli info args'
}
debug func $LINENO function 'cli::command::list() created.'

cli::command::expand() {
  for c in $1; do
    echo $c | sed -r 's/\// /g' 
  done
}
debug func $LINENO function 'cli::command::expand() created.'

cli::command::path() {
  echo $* | sed 's/ /\//g'
}
debug func $LINENO function 'cli::command::path() created.'

cli::command::syntax() {
  local METAFN
  # META: CREATE FUNCTION THAT CREATES:
                                                                  
     syntax_$CLI() {       ;# $SUBCOMMAND $DESCRIPTION
       local COMMMAND
       local SUBCLI
       local DESCRIPTION

       print
     }
                                                                  fi
  #
  # usage: cli::command::syntax $command $subcommand $description
  eval `printf 'syntax_%s() { print "%%16s %%s" $1 $2 ; }' $1` ; 
}
debug func $LINENO function 'cli::command::syntax() created.'

cmmmand_usage() {
  # META: CREATE FUNCTION THAT CREATES CANNED HEREDOC
  # usage: cli::command::usage $command $subcommand $heredoc
  local CLI
  local SUBCLI
  local HEREDOC
  eval `printf "usage_%s() { \ncat <<  }"`
}
debug func $LINENO function 'cli::command::usage() created.'


cli::command::help_all() {

}
debug func $LINENO function 'cli::command::help_all() created.'

cli::command::help() {
  local TOKEN
  local CMDPATH
  if [ $# -eq 0 ]; then
    cli::command::help_all
    return 0
  fi
  CMDLINE="$*"
  CMDPATH="."
  while [ $# -gt 0 ]; do
    TOKEN=$1 ; shift
    CMDPATH="${CMDPATH}/${TOKEN}"
    if [ -d "${CMDPATH}" ]
      continue
    fi
    if [ -f "${CMDPATH}" ]; then
      # CLI EXISTS IN PATH!
      if [ ! -x ${CMDPATH} ]; then

      fi
    else 
      # CLI DOES NOT EXISTS IN PATH
      ${CMDPATH}/.syntax SYNTAX "$*"
    fi
    
  done
}
debug func $LINENO function 'cli::command::help_all() created.'

cli::command::register_all() {
  local CREG
  for CREG in `cli::command::list`; do
    cli_command register $CREG
  done
}
debug func $LINENO function 'cli::command::register_all() created.'

cli::command::register() {
  local COMMAND=$1 ; # COMMAND TO REGISTER
  export CMD_REGISTERED
  case ${COMMAND} in
    all)      cli::command::register_all ;;

    *) 

    alias name=${COMMAND} ${BINROOT}/${COMMAND} ;
              [ -z ${CMD_REGISTERED} ] CMD_REGISTERED=${CMD_REGISTERED}:${COMMAND} ;;
  esac
}
debug func $LINENO function 'cli::command::register() created.'

cli::command() {
  local SUBCLI=$1
  case ${SUBCLI} in
    # CLIS
    list)     cli::command::list "$@";;
    expand)   cli::command::expand "$@";;
    register) cli::command::register "$@";;
    
    # DEFAULT 
    *)
      builtin cli_command ${SUBCLI};;
  esac
}
debug func $LINENO function 'cli::command::help_all() created.'



# vim:syntax=sh
