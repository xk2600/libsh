#!/usr/bin/printf %s: must be sourced from /bin/sh interpreter.\n
# vim syntax:sh

##
## istrue     VARNAME
## checkyesno VARNANE
##       test varname for truth, returning 1 else 0
##
## error      MESSAGE
## log        MESSAGE
##       allow output to stderr and logging to system log
##
## enable     INTERPOP
## disable    INTERPOP
##       enables or disables optional interpreter option
##
## ARGUMENTS
##
##       VARNAME             name of variable
##       NAMESPACE           command namespace
##       MESSAGE             message to be output

# istrue var
#
#       Test $1 variable, and warn if not set to YES or NO.
#       Return 0 if it's "yes" (et al), nonzero otherwise.
#
istrue() {
  eval _value=\$${1}
  debug "checkyesno: $1 is set to $_value."
  case $_value in

    #  "yes", "true", "on", or "1"
    [Yy][Ee][Ss]|[Tt][Rr][Uu][Ee]|[Oo][Nn]|1)
      return 0
      ;;
  
    #  "no", "false", "off", or "0"
    [Nn][Oo]|[Ff][Aa][Ll][Ss][Ee]|[Oo][Ff][Ff]|0)
      return 1
      ;;

    *)
      warn "\$${1} is not set properly - see rc.conf(5)."
      return 1
      ;;

  esac
}
alias checkyesno=istrue





# error message [var [...var]]
#
#       outputs message to stderr and returns an error.
# 
# ARGUMENTS
#
#       message
#             message to be output (printf format string)
#
#       var
#             variables to be replaced in message
#
# SIDE EFFECTS
#
#       with 'set -e' active, this will terminate the pipeline
#
error() {
  local MESSAGE
  local VARS

  MESSAGE=${1:?}
  # wrap vars in quotes
  while [ $# -gt 0 ]; do
    VARS="$VARS \"$1\"" ; shift
  done
  printf "$MESSAGE" $VARS >&2
  return 1
}



# log message
#
#       outputs message to stderr
# 
# ARGUMENTS
#
#       message
#             message to be output (printf format string)
#
#       var
#             variables to be replaced in message
#
# SIDE EFFECTS
#
#       with 'set -e' active, this will terminate the pipeline
#
log() {
  local MESSAGE
  local VARS

  MESSAGE=${1:?}
  # wrap vars in quotes
  while [ $# -gt 0 ]; do
    VARS="$VARS \"$1\"" ; shift
  done
  printf "$MESSAGE" $VARS >&2
}






# enable
enable() {
  local OPTION=$1
  # check to see if ${OPTION}::stator exists
  # execute ${OPTION}::stator enable if it does.
}

# disable
disable() {
  local OPTION=$1
  # check to see if ${OPTION}::stator exists
  # execute ${OPTION}::stator disable if it does.
}




ARGS() {
  local ARGS=`printf "'%s' " "$@"`   ;# wraps each argument in ticks (')
  echo "${ARGS%?}"                   ;# removes the last space
}




# usage 
#
#
usage() {
  OFS=$IFS
  IFS="\n"
  for f in $@; do
    echo 'usage: $@'
  done
  IFS=OFS
  exit -1
}
debug func $LINENO function 'usage() defined.'




. ${CLIROOT}/lib/debug
. ${CLIROOT}/cli/lib/


